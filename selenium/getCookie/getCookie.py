#! /usr/bin/python3
#-*- encoding: utf-8 -*-

# python3 -m pytest /data/docker/selenium/start_qq.py


# Generated by Selenium IDE
import pytest
import time
import json
import random
import os #导入os模块
from datetime import datetime
import subprocess



# import warnings
# import logging


from selenium import webdriver
from selenium.webdriver.common.by import By
# from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
# from selenium.webdriver.common.keys import Keys
# from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver import ChromeOptions
from selenium.webdriver import Chrome


class TestStartQq:
  # def setup_method(self, method):
  def setup_class(self):

    #第一步输入这个：去除开头警告
    # warnings.simplefilter('ignore',ResourceWarning)


    #控制台打印
    print("开始执行你的测试用例！")
    # logging.info("logging-开始执行你的测试用例! ")

    options = ChromeOptions()
    # @see https://github.com/lixi5338619/magical_spider/blob/main/browserapi.py
    # 隐藏自动化提示
    # options.add_experimental_option('excludeSwitches', ['enable-automation'])
    # options.add_experimental_option('useAutomationExtension', False)

    ua = '--user-agent=Mozilla/5.0 (Windows NT 6.1; Win64; x64) >AppleWebKit/536.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/536.36 Edg/87.0.664.57'
    #针对UA请求头的操作，防止因为没有添加请求头导致的访问被栏截了
    # options.add_argument('User-Agent=Mozilla/5.0 (Windows NT 6.1; Win64; x64) >AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Edg/87.0.664.57')
    # options.add_argument('User-Agent=Chrome/87.0.4280.88')
    # options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 6.1; Win64; x64) >AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Edg/87.0.664.57')
    
    # options.add_argument(ua)
    # 下面的过期了
    # options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11')

    # 指定已经打开浏览器的地址及端口号
    # options.add_experimental_option("debuggerAddress", "chrome.common-all:1234")
    options.add_experimental_option("debuggerAddress", "127.0.0.1:1234")

    # proxy_address = "nohost.common-all:8899"
    # options.add_argument(f"--proxy-server={proxy_address}")

    # options.add_argument("--user-data-dir=/tmp/selenium/")

    # 无痕模式
    # options.add_argument('--incognito')


    # options.add_argument('--headless')
    # options.add_argument('--start-maximized')

    

    # options.add_argument('--disable-gpu')
    # options.add_argument('--no-sandbox')
    # options.add_argument('--auto-open-devtools-for-tabs')

    # Chrome在/dev/shm中创建一个较大的临时文件，用于存储浏览器会话的数据。
    # 这包括缓存、网页渲染过程中生成的中间结果等。
    # 然而，使用Docker等容器技术时，/dev/shm通常被配置为非常小的大小，因此可能无法容纳Chrome所需的临时文件。
    # docker运行必备，否则经常奔溃
    # options.add_argument('--disable-dev-shm-usage')

    # 指定Firefox浏览器程序地址
    # options.binary_location = '/usr/bin/chrome'



    bro = Chrome(options=options)
    # bro.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {
    #   "source": """
    #     Object.defineProperty(navigator, 'webdriver', {
    #       get: () => undefined
    #     })
    #   """
    # })

    # bro.execute_cdp_cmd('Network.setUserAgentOverride', {"userAgent": ua})

    with open('/getCookie/stealth.min.js', 'r') as f:
        js = f.read()
    # 调用函数在页面加载前执行脚本
    bro.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {'source': js})

    #第二个输入这个：隐藏式启动谷歌浏览器执行UI测试用例
    # chrome_options = Options()
    # chrome_options.add_argument('--headless')


    # self.driver = webdriver.Chrome(options=chrome_options)
    self.driver = bro
    self.vars = {}

    now = datetime.now()
    self.date_time = now.strftime("%Y-%m-%d--%H-%M-%S")  # 获取当前日期和时间，格式化为字符串

    # self.driver.set_window_size(1024, 768)
    # document.elementFromPoint(354,389);
    # $0.getBoundingClientRect()
  
  # def teardown_method(self, method):
  #   self.driver.quit()

  def teardown_class(self):
    self.driver.quit()
  
  
  # 保存截图文件
  def saveHtml(self, filename):
    print('触发截图到当前代码目录--' + filename)


    # 创建以日期时间命名的文件夹
    folder_path = os.path.join(self.fileDir(), self.date_time)
    os.makedirs(folder_path, exist_ok=True)

    screenshot_path = os.path.join(folder_path, filename + '.png')
    self.driver.save_screenshot(screenshot_path)
    print('截图保存至：', screenshot_path)

    # 你可以保存源代码为 html 再双击打开，查看完整结果
    # source = self.driver.page_source
    # with open(self.fileDir() + '/' +filename+'.html', 'w') as f:
    #     f.write(source)

  # 获取当前脚本目录路径
  def fileDir(self):
    dataDir = os.getenv('DATA_DIR')
    if dataDir:
       return dataDir

    return os.path.dirname(os.path.abspath(__file__))


  def test_login(self):
    # logging.info("logging-开始执行你的测试用例！--test_login")
    print("开始执行你的测试用例！--test_login")
    # Test name: 登录
    # Step # | name | target | value
    # 1 | open | /game/dnf/?ADTAG=web-start-dnf-all | 
    urlEnv = os.getenv('URL')

    print("打开链接为： " + urlEnv)


    self.driver.get(urlEnv)


    time.sleep(1)

    print("window.open： " + urlEnv)
    self.driver.execute_script("window.open('"+urlEnv+"')")



    print('等待命令执行打开的页面--开始')
    command = "chrome " + urlEnv  # 替换为你要执行的命令

    # 执行命令并等待其返回，同时捕获输出
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    # 读取命令输出并将其打印到当前命令行
    for line in process.stdout:
        print(line.decode().rstrip())

    print('等待命令执行打开的页面--返回')
    # 等待命令完成
    process.wait()

    
    # print('等待命令执行打开的页面--返回后再等25s')
    # time.sleep(25)



    # print('self.driver.window_handles')
    # print(self.driver.window_handles)

    # 能成功切换到
    # print('switch_to.window 第三个')
    # self.driver.switch_to.window(self.driver.window_handles[2])
    
    # print('刷新')
    # self.driver.refresh()

    # methods = [method for method in dir(self.driver) if callable(getattr(self.driver, method))]

    # print(methods)
    # print(dir(self.driver))

    # self.driver.reconnect();
    # return
    
    time.sleep(5)
    # self.saveHtml('sleep-5---get')


    debugSleep = os.getenv('DEBUG_SLEEP')
    if debugSleep:
      #  return dataDir
      time.sleep(debugSleep)
    # return
  
    # self.driver.implicitly_wait(10)

    # random_delay = random.random() * 1

    # time.sleep(2)

    
    # self.saveHtml('打开网站后2s的截图')


    WebDriverWait(self.driver, 10).until(
        lambda x: x.execute_script("return document.readyState") == "complete"  
    )

    # 返回当前浏览器的ua
    print("当前浏览器内置user-agent:", self.driver.execute_script('return navigator.userAgent'))


    # self.driver.execute_script("window.location.reload();")

    print("window.location.href")
    print( self.driver.execute_script("return window.location.href"))

    if_find_elements = os.getenv('FIND_ELEMENTS_XPATH')
    ifCookieKey = os.getenv('IF_COOKIE_KEY')


    self.saveHtml('开始循环前截图')

    # 方法1:循环20次
    breakBool = 0
    for i in range(10):
        if breakBool:
           break
        
        WebDriverWait(self.driver, 10).until(
            lambda x: x.execute_script("return document.readyState") == "complete"  
        )

        # 判断cookie是否存在
        if ifCookieKey:
            cookies = self.driver.get_cookies()
            print(cookies)
            for cookie in cookies:
                if (cookie["name"] == ifCookieKey):
                   print('cookie 已成功找到')
                   print(cookie)
                   breakBool=1
                   break

        if breakBool:
           break

        # time.sleep(1)
        if if_find_elements:
            # 点击元素
            print('查找 ' + if_find_elements)
            elements = self.driver.find_elements(By.XPATH, '//' + if_find_elements)

            refreshBool = True
            for element in elements:
                print('点击')
                print(element)
                element.click()
                refreshBool = False
            
            if refreshBool:
              print('刷新')
              self.driver.refresh()



        # 搜索所有元素
        # elements = self.driver.find_elements(By.XPATH, '//*')

        # # 遍历每个元素
        # for element in elements:
        #     # print(element)
        #     attributes_list = element.get_property('attributes')
        #     # print(attributes_list)

        #     if attributes_list:
        #         # 遍历属性字典
        #         for attributes in attributes_list:
        #             for name, value in attributes.items():
        #                 # 判断属性值是否包含文本
        #                 if ifText in str(value):
        #                     element.click()
        #                     break 


        #     # 检查属性是否包含"点击" 
        #     # if ifText in element.get_attribute("textContent"):
        #     #     element.click()
        #     #     break
            
        #     # 检查innerText是否包含   
        #     if ifText in str(element.text):
        #         element.click()
        #         break
        
               
        sleepInt = 5
        print("循环等待"+str(sleepInt)+"s")
        time.sleep(sleepInt)
        
        self.saveHtml('循环点击后'+str(sleepInt)+'s截图-' + str(i))
    
    # print("整体等待")
    # time.sleep(8)
    # time.sleep(11118)

    
    print("window.location.href")
    print(self.driver.execute_script("return window.location.href"))

    print('输出cookie');
    cookies = self.driver.get_cookies()
    print(cookies);
    # await self.driver.manage().getCookies().then(function (cookie) {
    #     console.log('cookie details => ', cookie);
    # });

    # 组装成字符串
    cookie_str = ""
    for cookie in cookies:
      cookie_str += cookie["name"] + "=" + cookie["value"] + ";"

    # 去除末尾的分号空格  
    cookie_str = cookie_str.strip(";") 

    # 写入文件
    # with open("cookies.txt", "w") as f:
    #   f.write(cookie_str)

    file_path = os.getenv("COOKIE_FILE_PATH")

    if file_path:
      print("写入文件地址" + file_path)
      with open(file_path, "w") as f:
        f.write(cookie_str)  
    else:
      print('---------------------------------------')
      print('---------------------------------------')
      print("cookie"+"_env " + cookie_str)
      print('---------------------------------------')
      print('---------------------------------------')



if __name__ == "__main__":
    pytest.main(["--capture=no", __file__])
    # pytest.main(["--log-level=info", "--capture=no", __file__])
