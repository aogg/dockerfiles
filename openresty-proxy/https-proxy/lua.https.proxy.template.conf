
# 必须
resolver 127.0.0.11;                                                                                                        



server {
    listen 80 default_server;
    listen 443 ssl;
    # listen 443;
    server_name _;

    # 用于满足 Nginx 配置的占位符
    # ssl_certificate /etc/nginx/ssl/default.crt;
    # ssl_certificate_key /etc/nginx/ssl/default.key;
    ssl_certificate /etc/nginx/ssl/www.sfinace.xyz.crt;
    ssl_certificate_key /etc/nginx/ssl/www.sfinace.xyz.key;

    # location / {
    ssl_certificate_by_lua_block {
            ngx.log(ngx.ERR, "qqqqqqqq")
            local ssl = require "ngx.ssl"

        local ok, err = ssl.clear_certs()
        if not ok then
            ngx.log(ngx.ERR, "failed to clear existing (fallback) certificates")
            return ngx.exit(ngx.ERROR)
        end
        

        ngx.log(ngx.ERR, "ggggggggggggggg")
        local ssl_dir = "/etc/nginx/ssl"
        local domain = ngx.var.server_name
        local cert_path = ssl_dir .. "/" .. domain .. ".crt"
        local key_path = ssl_dir .. "/" .. domain .. ".key"
        
        ngx.log(ngx.ERR, cert_path)
        ngx.log(ngx.ERR, key_path)

        -- local has_cert = (ngx.req.get_headers()["Host"] == domain) and (file_exists(cert_path))

        -- if has_cert then
            -- 获取证书内容，比如 io.open("my.crt"):read("*a")
            local cert_data, err = get_my_pem_cert_data()
            if not cert_data then
                ngx.log(ngx.ERR, "failed to get PEM cert: ", err)
                return
            end
            -- 解析出 cdata 类型的证书值，你可以用 lua-resty-lrucache 缓存解析结果
            local cert, err = ssl.parse_pem_cert(cert_data)
            if not cert then
                ngx.log(ngx.ERR, "failed to parse PEM cert: ", err)
                return
            end
            local ok, err = ssl.set_cert(cert)
            if not ok then
                ngx.log(ngx.ERR, "failed to set cert: ", err)
                return
            end
            local pkey_data, err = get_my_pem_priv_key_data()
            if not pkey_data then
                ngx.log(ngx.ERR, "failed to get DER private key: ", err)
                return
            end
            local pkey, err = ssl.parse_pem_priv_key(pkey_data)
            if not pkey then
                ngx.log(ngx.ERR, "failed to parse pem key: ", err)
                return
            end
            local ok, err = ssl.set_priv_key(pkey)
            if not ok then
                ngx.log(ngx.ERR, "failed to set private key: ", err)
                return
            end
        -- end
            ngx.log(ngx.ERR, "eeeeeeeeeeeeeeeeeeeeee")
    }

    location / {
        proxy_pass https://www.baidu.com;
    }

    # access_by_lua_block {
    #     local ssl_dir = "/etc/nginx/ssl"
    #     local domain = ngx.var.host
    #     local cert_path = ssl_dir .. "/" .. domain .. ".crt"
    #     local key_path = ssl_dir .. "/" .. domain .. ".key"

    #     local file_path = "/tmp/a.log"
    #     local message = "这是一条调试信息"


    #     ngx.log(ngx.ERR, "qqqqqqqqqqqqqqqqqqqqqqqqqqqq")

    #     -- 打开文件以追加写入模式
    #     local file = io.open(file_path, "a")
    #     if file then
    #         -- 写入调试信息并换行
    #         file:write(message .. "\n")
    #         -- 关闭文件
    #         file:close()
    #     else
    #         ngx.log(ngx.ERR, "无法打开文件：" .. file_path)
    #     end


    #     # local has_cert = (ngx.req.get_headers()["Host"] == domain) and (file_exists(cert_path))

    #     # if has_cert then
    #         ngx.var.ssl = "on"
    #         ngx.var.ssl_certificate = cert_path
    #         ngx.var.ssl_certificate_key = key_path
    #         # ngx.var.proxy_pass = "https://" .. domain .. ngx.var.request_uri
    #     # else
    #         # ngx.var.proxy_pass = "https://www.baidu.com" .. ngx.var.request_uri
    #     # end
    # }
    # }
}

# function file_exists(path)
#     local file = io.open(path, "r")
#     if file then
#         file:close()
#         return true
#     else
#         return false
#     end
# end







